package com.weelo.logistics.utils

/**
 * Input Validation Utility
 * 
 * Provides centralized validation for all user inputs
 * Prevents injection attacks, XSS, and malformed data
 * 
 * SECURITY: All user input MUST be validated before processing
 */
object InputValidator {
    
    // Phone number validation
    fun validatePhoneNumber(phone: String): ValidationResult {
        return when {
            phone.isEmpty() -> ValidationResult.Error("Phone number is required")
            phone.length != 10 -> ValidationResult.Error("Phone number must be 10 digits")
            !phone.all { it.isDigit() } -> ValidationResult.Error("Phone number must contain only digits")
            !phone.startsWith("6") && !phone.startsWith("7") && !phone.startsWith("8") && !phone.startsWith("9") -> 
                ValidationResult.Error("Invalid phone number")
            else -> ValidationResult.Success
        }
    }
    
    // OTP validation
    fun validateOTP(otp: String): ValidationResult {
        return when {
            otp.isEmpty() -> ValidationResult.Error("OTP is required")
            otp.length != 6 -> ValidationResult.Error("OTP must be 6 digits")
            !otp.all { it.isDigit() } -> ValidationResult.Error("OTP must contain only digits")
            else -> ValidationResult.Success
        }
    }
    
    // Name validation
    fun validateName(name: String): ValidationResult {
        val sanitized = sanitizeInput(name)
        return when {
            sanitized.isEmpty() -> ValidationResult.Error("Name is required")
            sanitized.length < 3 -> ValidationResult.Error("Name must be at least 3 characters")
            sanitized.length > 100 -> ValidationResult.Error("Name is too long (max 100 characters)")
            !sanitized.matches(Regex("^[a-zA-Z\\s.'-]+$")) -> 
                ValidationResult.Error("Name contains invalid characters")
            else -> ValidationResult.Success
        }
    }
    
    // Location validation
    fun validateLocation(location: String): ValidationResult {
        val sanitized = sanitizeInput(location)
        return when {
            sanitized.isEmpty() -> ValidationResult.Error("Location is required")
            sanitized.length < 3 -> ValidationResult.Error("Location is too short")
            sanitized.length > 200 -> ValidationResult.Error("Location is too long (max 200 characters)")
            else -> ValidationResult.Success
        }
    }
    
    // Vehicle number validation
    fun validateVehicleNumber(vehicleNumber: String): ValidationResult {
        val sanitized = sanitizeInput(vehicleNumber).uppercase().replace(" ", "")
        return when {
            sanitized.isEmpty() -> ValidationResult.Error("Vehicle number is required")
            !sanitized.matches(Regex("^[A-Z]{2}[0-9]{1,2}[A-Z]{1,2}[0-9]{4}$")) -> 
                ValidationResult.Error("Invalid vehicle number format (e.g., MH12AB1234)")
            else -> ValidationResult.Success
        }
    }
    
    // Driver license validation
    fun validateDriverLicense(license: String): ValidationResult {
        val sanitized = sanitizeInput(license).uppercase().replace(" ", "")
        return when {
            sanitized.isEmpty() -> ValidationResult.Error("License number is required")
            sanitized.length < 10 -> ValidationResult.Error("License number is too short")
            sanitized.length > 20 -> ValidationResult.Error("License number is too long")
            else -> ValidationResult.Success
        }
    }
    
    // Email validation (optional field)
    fun validateEmail(email: String): ValidationResult {
        if (email.isEmpty()) return ValidationResult.Success // Optional
        
        val sanitized = sanitizeInput(email)
        return when {
            sanitized.length > 254 -> ValidationResult.Error("Email is too long")
            !sanitized.matches(Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) ->
                ValidationResult.Error("Invalid email format")
            else -> ValidationResult.Success
        }
    }
    
    // Sanitize input - remove potentially dangerous characters
    fun sanitizeInput(input: String): String {
        return input
            .trim()
            .replace(Regex("[<>\"'&]"), "") // Remove HTML/Script injection chars
            .take(500) // Max length limit
    }
    
    // Sanitize for SQL - although we should use parameterized queries
    fun sanitizeForSQL(input: String): String {
        return input
            .replace("'", "''")
            .replace(";", "")
            .replace("--", "")
            .replace("/*", "")
            .replace("*/", "")
    }
    
    // Generic string validation with length constraints
    fun validateString(
        value: String,
        fieldName: String,
        minLength: Int = 1,
        maxLength: Int = 500,
        allowSpecialChars: Boolean = false
    ): ValidationResult {
        val sanitized = sanitizeInput(value)
        
        return when {
            sanitized.isEmpty() -> ValidationResult.Error("$fieldName is required")
            sanitized.length < minLength -> ValidationResult.Error("$fieldName must be at least $minLength characters")
            sanitized.length > maxLength -> ValidationResult.Error("$fieldName is too long (max $maxLength characters)")
            !allowSpecialChars && sanitized.matches(Regex(".*[<>\"'&;].*")) ->
                ValidationResult.Error("$fieldName contains invalid characters")
            else -> ValidationResult.Success
        }
    }
    
    // Numeric validation
    fun validateNumeric(value: String, fieldName: String, min: Int? = null, max: Int? = null): ValidationResult {
        return try {
            val number = value.toInt()
            when {
                min != null && number < min -> ValidationResult.Error("$fieldName must be at least $min")
                max != null && number > max -> ValidationResult.Error("$fieldName must be at most $max")
                else -> ValidationResult.Success
            }
        } catch (e: NumberFormatException) {
            ValidationResult.Error("$fieldName must be a valid number")
        }
    }
}

sealed class ValidationResult {
    object Success : ValidationResult()
    data class Error(val message: String) : ValidationResult()
    
    val isValid: Boolean
        get() = this is Success
    
    val errorMessage: String?
        get() = (this as? Error)?.message
}

    /**
     * Validate name with length limits
     * Security: Enforces min/max length
     */
    fun validateName(name: String): ValidationResult {
        val trimmedName = name.trim()
        
        if (trimmedName.isBlank()) {
            return ValidationResult(false, "Name is required")
        }
        
        if (trimmedName.length < Limits.NAME_MIN_LENGTH) {
            return ValidationResult(false, "Name must be at least ${Limits.NAME_MIN_LENGTH} characters")
        }
        
        if (trimmedName.length > Limits.NAME_MAX_LENGTH) {
            return ValidationResult(false, "Name cannot exceed ${Limits.NAME_MAX_LENGTH} characters")
        }
        
        // Allow letters, spaces, dots, and hyphens
        if (!trimmedName.matches(Regex("^[a-zA-Z\\s.'-]+$"))) {
            return ValidationResult(false, "Name can only contain letters, spaces, dots, and hyphens")
        }
        
        return ValidationResult(true)
    }
    
    /**
     * Validate license number with length limits
     * Security: Enforces min/max length
     */
    fun validateLicenseNumber(license: String): ValidationResult {
        val trimmedLicense = license.trim()
        
        if (trimmedLicense.isBlank()) {
            return ValidationResult(false, "License number is required")
        }
        
        if (trimmedLicense.length < Limits.LICENSE_MIN_LENGTH) {
            return ValidationResult(false, "License number must be at least ${Limits.LICENSE_MIN_LENGTH} characters")
        }
        
        if (trimmedLicense.length > Limits.LICENSE_MAX_LENGTH) {
            return ValidationResult(false, "License number cannot exceed ${Limits.LICENSE_MAX_LENGTH} characters")
        }
        
        return ValidationResult(true)
    }
    
    /**
     * Validate OTP with exact length
     * Security: Enforces exact 6-digit length
     */
    fun validateOTP(otp: String): ValidationResult {
        val trimmedOTP = otp.trim()
        
        if (trimmedOTP.isBlank()) {
            return ValidationResult(false, "OTP is required")
        }
        
        if (trimmedOTP.length != Limits.OTP_LENGTH) {
            return ValidationResult(false, "OTP must be exactly ${Limits.OTP_LENGTH} digits")
        }
        
        if (!trimmedOTP.matches(Regex("^\\d{${Limits.OTP_LENGTH}}$"))) {
            return ValidationResult(false, "OTP must contain only digits")
        }
        
        return ValidationResult(true)
    }
    
    /**
     * Validate vehicle registration number
     * Security: Enforces length limits
     */
    fun validateVehicleRegistration(regNumber: String): ValidationResult {
        val trimmedReg = regNumber.trim().uppercase()
        
        if (trimmedReg.isBlank()) {
            return ValidationResult(false, "Vehicle registration is required")
        }
        
        if (trimmedReg.length < Limits.VEHICLE_REG_MIN_LENGTH) {
            return ValidationResult(false, "Registration must be at least ${Limits.VEHICLE_REG_MIN_LENGTH} characters")
        }
        
        if (trimmedReg.length > Limits.VEHICLE_REG_MAX_LENGTH) {
            return ValidationResult(false, "Registration cannot exceed ${Limits.VEHICLE_REG_MAX_LENGTH} characters")
        }
        
        return ValidationResult(true)
    }
    
    /**
     * Validate address with length limits
     * Security: Enforces min/max length
     */
    fun validateAddress(address: String): ValidationResult {
        val trimmedAddress = address.trim()
        
        if (trimmedAddress.isBlank()) {
            return ValidationResult(false, "Address is required")
        }
        
        if (trimmedAddress.length < Limits.ADDRESS_MIN_LENGTH) {
            return ValidationResult(false, "Address must be at least ${Limits.ADDRESS_MIN_LENGTH} characters")
        }
        
        if (trimmedAddress.length > Limits.ADDRESS_MAX_LENGTH) {
            return ValidationResult(false, "Address cannot exceed ${Limits.ADDRESS_MAX_LENGTH} characters")
        }
        
        return ValidationResult(true)
    }
    
    /**
     * Validate pincode
     * Security: Enforces exact 6-digit length
     */
    fun validatePincode(pincode: String): ValidationResult {
        val trimmedPincode = pincode.trim()
        
        if (trimmedPincode.isBlank()) {
            return ValidationResult(false, "Pincode is required")
        }
        
        if (trimmedPincode.length != Limits.PINCODE_LENGTH) {
            return ValidationResult(false, "Pincode must be exactly ${Limits.PINCODE_LENGTH} digits")
        }
        
        if (!trimmedPincode.matches(Regex("^\\d{${Limits.PINCODE_LENGTH}}$"))) {
            return ValidationResult(false, "Pincode must contain only digits")
        }
        
        return ValidationResult(true)
    }
